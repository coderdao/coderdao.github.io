---
layout:     post
title:      GC(垃圾回收)原理
subtitle:   GC(垃圾回收)原理
date:       2021-06-03
author:     锐玩道
header-img: img/bg_img/post-bg-cook.jpg
catalog:    true
theme:      smartblue
tags:
    - golang
---

> 如果❤️我的文章有帮助，欢迎点赞、关注。这是对我继续技术创作最大的鼓励。[更多往期文章在我的个人博客](https://coderdao.github.io/)


## 什么是垃圾回收(GC)
`垃圾回收算法` 中比较常见的有 `标记清除(Mark-Sweep)` 和 `引用计数(Reference Count)`，而Golang 采用 `标记清除法`。并在 `标记清除法` 上使用 `三色标记法` 和 `写屏障` 等技术大大提高工作效率。

`标记清除`收集器是 `跟踪式` 垃圾收集器，它的工作流程大致分为两个阶段：`标记(Mark)` 和 `清除(Sweep)`：

- 标记阶段 — 从 `根对象(root)` 开始查找并标记 `堆` 中 `所有存活对象`
- 清除阶段 — 回收 `堆中未被标记` 的垃圾对象 并 将 `回收的内存加入空闲链表`

## 什么是三色标记法
> `标记清除算法` 有一大问题：`标记阶段` 需要 `完全暂停程序(Stop the world，STW)`。标记结束后，用户程序才能继续执行。

> Golang 为了能够`异步执行`、`减少 STW` 的时间，从 Golang v1.5 版本实现了基于 `三色标记法` 的并发垃圾收集器。

三色标记算法将程序中的对象分成`白色`、`黑色`、`灰色`三类。
- 白色：不确定对象
- 灰色：存活对象，子对象待处理
- 黑色：存活对象

### 标记过程
【漫画】

1. 标记开始：所有对象加入白色集合(这一步需 STW)。
2. 将 `根对象` 标记为 `灰色`，加入 `灰色集合`
3. 垃圾搜集器取出一个灰色对象，将其标记为黑色，并将其`指向对象`标记为`灰色`，加入灰色集合。
4. 重复 `第三步过程`，直到灰色集合为空为止
5. 标记阶段结束：那么白色对象为`需要清理对象`；而黑色对象为`根可达对象`，不能被清理。


## 并发时三色法存在的问题
由于 `三色标记法` 多了一个 `白色状态` 来存放 `不确定对象`。
结合`并发执行`的后续标记阶段，就有可能会造成一些遗漏：比如早先被标记为`黑色对象` 可能目前已经`变不可达`。

三色标记法并发执行仍存在一个问题，即在 GC 过程中，对象指针发生了改变。比如下面的例子：
> A (黑) -> B (灰) -> C (白) -> D (白)

正常情况下，D 对象最终会被标记为黑色，不应被回收。但在标记和用户程序并发执行过程中，用户程序删除了 C 对 D 的引用，而 A 获得了 D 的引用。标记继续进行，D 就没有机会被标记为黑色了（A 已经处理过，这一轮不会再被处理）。
```text
A (黑) -> B (灰) -> C (白) 
  ↓
 D (白)
```

所以三色标记法是一个 false negative（假阴性）的算法。

## 什么是写屏障
为了解决这个问题，Go 使用了内存屏障技术，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，类似于一个钩子。垃圾收集器使用了写屏障（Write Barrier）技术，当对象新增或更新时，会将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。

这个时候就需要我们的写屏障出马了。写屏障主要做一件事情，修改原先的写逻辑，然后在对象新增的同时给它着色，并且着色为灰色。因此打开了写屏障可以保证了三色标记法在并发下安全正确地运行。那么有人就会问这些写屏障标记成灰色的对象什么时候回收呢？答案是后续的 GC 过程中回收，在新的 GC 过程中所有已存对象就又从白色开始逐步被标记啦。


## 完整的 GC 分为四个阶段：

1）标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)
2）使用三色标记法标记（Marking, 并发）
3）标记结束(Mark Termination，需 STW)，关闭写屏障。
4）清理(Sweeping, 并发)


## 参考
[fullstack](https://www.fullstack.cafe/golang)
[垃圾收集器](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/)