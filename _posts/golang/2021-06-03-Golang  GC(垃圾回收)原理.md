---
layout:     post
title:      GC(垃圾回收)原理
subtitle:   GC(垃圾回收)原理
date:       2021-06-03
author:     锐玩道
header-img: img/bg_img/post-bg-cook.jpg
catalog:    true
theme:      smartblue
tags:
    - golang
---

> 如果❤️我的文章有帮助，欢迎点赞、关注。这是对我继续技术创作最大的鼓励。[更多往期文章在我的个人博客](https://coderdao.github.io/)


## 什么是垃圾回收(GC)
`垃圾回收算法` 中比较常见的有 `标记清除(Mark-Sweep)` 和 `引用计数(Reference Count)`，而Golang 采用 `标记清除法`。并在 `标记清除法` 上使用 `三色标记法` 和 `写屏障` 等技术大大提高工作效率。

`标记清除`收集器是 `跟踪式` 垃圾收集器，它的工作流程大致分为两个阶段：`标记(Mark)` 和 `清除(Sweep)`：

- 标记阶段 — 从 `根对象(root)` 开始查找并标记 `堆` 中 `所有存活对象`
- 清除阶段 — 回收 `堆中未被标记` 的垃圾对象 并 将 `回收的内存加入空闲链表`

## 什么是三色标记法
> `标记清除算法` 有一大问题：`标记阶段` 需要 `完全暂停程序(Stop the world，STW)`。标记结束后，用户程序才能继续执行。

> Golang 为了能够`异步执行`、`减少 STW` 的时间，从 Golang v1.5 版本实现了基于 `三色标记法` 的并发垃圾收集器。

三色标记算法将程序中的对象分成`白色`、`黑色`、`灰色`三类。
- 白色：不确定对象
- 灰色：存活对象，子对象待处理
- 黑色：存活对象

### 标记过程
- 标记开始时，所有对象加入白色集合(这一步需 STW)。
- 遍历根节点集合里的所有根对象，把根对象引用的对象标记为灰色，从白色集合放入灰色集合。
- 将 `根对象` 标记为 `灰色`，加入 `灰色集合`，垃圾搜集器取出一个灰色对象，将其标记为黑色，并将其指向的对象标记为灰色，加入灰色集合。重复这个过程，直到灰色集合为空为止，

标记阶段结束。那么白色对象即可需要清理的对象，而黑色对象均为根可达的对象，不能被清理。

三色标记法因为多了一个白色的状态来存放不确定对象，所以后续的标记阶段可以并发地执行。当然并发执行的代价是可能会造成一些遗漏，因为那些早先被标记为黑色的对象可能目前已经是不可达的了。所以三色标记法是一个 false negative（假阴性）的算法。

三色标记法并发执行仍存在一个问题，即在 GC 过程中，对象指针发生了改变。比如下面的例子：
> A (黑) -> B (灰) -> C (白) -> D (白)
正常情况下，D 对象最终会被标记为黑色，不应被回收。但在标记和用户程序并发执行过程中，用户程序删除了 C 对 D 的引用，而 A 获得了 D 的引用。标记继续进行，D 就没有机会被标记为黑色了（A 已经处理过，这一轮不会再被处理）。
```text
A (黑) -> B (灰) -> C (白) 
  ↓
 D (白)
```

为了解决这个问题，Go 使用了内存屏障技术，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，类似于一个钩子。垃圾收集器使用了写屏障（Write Barrier）技术，当对象新增或更新时，会将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。

一次完整的 GC 分为四个阶段：

1）标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)
2）使用三色标记法标记（Marking, 并发）
3）标记结束(Mark Termination，需 STW)，关闭写屏障。
4）清理(Sweeping, 并发)


## 参考
[fullstack](https://www.fullstack.cafe/golang)